\# ADR-001: Винесення доступу до SQLite у Repository Layer



\*\*Status:\*\* Accepted  

\*\*Date:\*\* \[INSERT DATE]  

\*\*Context:\*\* EduPlanner (Android / SQLite) – модуль розкладу



---



\## Context

У legacy-реалізації бізнес-логіка додавання заняття та перевірки конфліктів була реалізована безпосередньо в методі, який також виконує SQL-запити до SQLite. Це призводить до:



\- змішування відповідальностей (validation + business rules + DB);

\- складності модифікації логіки конфліктів;

\- низької тестованості (важко писати unit-тести без БД);

\- підвищеного ризику помилок через SQL-конкатенацію.



---



\## Decision

Виділити окремий шар доступу до даних `ScheduleRepository`, який інкапсулює SQL-запити до SQLite, та залишити бізнес-логіку в `ScheduleService`.



---



\## Consequences

\### Positive

\- Зниження зв’язності: сервіс не знає деталей SQLite.

\- Покращення тестованості: `ScheduleService` можна тестувати з моками репозиторію.

\- Зрозуміліша структура коду та простіша підтримка.

\- Безпечніший доступ до БД через параметризовані запити.



\### Negative / Trade-offs

\- Трохи більше файлів та “бойлерплейту”.

\- Потрібно дисципліновано не повертати SQL у Service/UI.



---



\## Notes

Це рішення є базою для подальших покращень: транзакції, кешування, міграції БД, перехід на Room/ORM тощо.



